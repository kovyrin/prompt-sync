package gitignore

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

const (
	beginMarker = "# BEGIN PROMPT-SYNC MANAGED"
	endMarker   = "# END PROMPT-SYNC MANAGED"
)

// Manager handles the managed block in .gitignore files
type Manager struct {
	workspaceDir string
}

// New creates a new gitignore manager
func New(workspaceDir string) *Manager {
	return &Manager{workspaceDir: workspaceDir}
}

// Update inserts or updates the managed block in .gitignore
func (m *Manager) Update(patterns []string) error {
	gitignorePath := filepath.Join(m.workspaceDir, ".gitignore")

	// Read existing content
	content, err := m.readGitignore(gitignorePath)
	if err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to read .gitignore: %w", err)
	}

	// Remove any existing managed block
	content = m.removeManagedBlock(content)

	// Create the new managed block
	managedBlock := m.createManagedBlock(patterns)

	// Append the managed block
	if len(content) > 0 && !strings.HasSuffix(content, "\n") {
		content += "\n"
	}
	if len(content) > 0 {
		content += "\n" // Extra newline before managed block
	}
	content += managedBlock

	// Write back to file
	if err := os.WriteFile(gitignorePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write .gitignore: %w", err)
	}

	return nil
}

// Verify checks if the managed block exists and is up to date
func (m *Manager) Verify(expectedPatterns []string) (bool, error) {
	gitignorePath := filepath.Join(m.workspaceDir, ".gitignore")

	content, err := m.readGitignore(gitignorePath)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, fmt.Errorf("failed to read .gitignore: %w", err)
	}

	// Extract current managed block
	currentBlock := m.extractManagedBlock(content)
	if currentBlock == "" {
		return false, nil
	}

	// Compare with expected
	expectedBlock := m.createManagedBlock(expectedPatterns)
	return currentBlock == expectedBlock, nil
}

func (m *Manager) readGitignore(path string) (string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func (m *Manager) removeManagedBlock(content string) string {
	lines := strings.Split(content, "\n")
	var result []string
	inManagedBlock := false

	for _, line := range lines {
		if line == beginMarker {
			inManagedBlock = true
			continue
		}
		if line == endMarker {
			inManagedBlock = false
			continue
		}
		if !inManagedBlock {
			result = append(result, line)
		}
	}

	// Trim trailing empty lines
	for len(result) > 0 && result[len(result)-1] == "" {
		result = result[:len(result)-1]
	}

	return strings.Join(result, "\n")
}

func (m *Manager) extractManagedBlock(content string) string {
	scanner := bufio.NewScanner(strings.NewReader(content))
	var block []string
	inBlock := false

	for scanner.Scan() {
		line := scanner.Text()
		if line == beginMarker {
			inBlock = true
			block = append(block, line)
		} else if line == endMarker {
			block = append(block, line)
			break
		} else if inBlock {
			block = append(block, line)
		}
	}

	if len(block) == 0 {
		return ""
	}

	return strings.Join(block, "\n") + "\n"
}

func (m *Manager) createManagedBlock(patterns []string) string {
	var lines []string
	lines = append(lines, beginMarker)
	lines = append(lines, "# DO NOT EDIT - Automatically generated by prompt-sync")
	lines = append(lines, "")
	lines = append(lines, patterns...)
	lines = append(lines, endMarker)

	return strings.Join(lines, "\n") + "\n"
}
