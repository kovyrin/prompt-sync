package lock

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

// Source represents a locked source in the lock file
type Source struct {
	URL    string `yaml:"url"`
	Ref    string `yaml:"ref,omitempty"`
	Commit string `yaml:"commit"`
	Files  []File `yaml:"files"`
}

// File represents a file with its hash
type File struct {
	Path string `yaml:"path"`
	Hash string `yaml:"hash"`
}

// Lock represents the complete lock file structure
type Lock struct {
	Version   string    `yaml:"version"`
	Generated time.Time `yaml:"generated"`
	Sources   []Source  `yaml:"sources"`
}

// Writer handles lock file generation and parsing
type Writer struct {
	workspaceDir string
}

// New creates a new lock writer
func New(workspaceDir string) *Writer {
	return &Writer{workspaceDir: workspaceDir}
}

// Write generates and writes a lock file
func (w *Writer) Write(sources []Source) error {
	lockPath := filepath.Join(w.workspaceDir, "Promptsfile.lock")

	// Sort sources for deterministic output
	sort.Slice(sources, func(i, j int) bool {
		return sources[i].URL < sources[j].URL
	})

	// Sort files within each source
	for i := range sources {
		sort.Slice(sources[i].Files, func(a, b int) bool {
			return sources[i].Files[a].Path < sources[i].Files[b].Path
		})
	}

	lock := Lock{
		Version:   "1.0",
		Generated: time.Now().UTC(),
		Sources:   sources,
	}

	// Marshal to YAML
	data, err := yaml.Marshal(&lock)
	if err != nil {
		return fmt.Errorf("failed to marshal lock file: %w", err)
	}

	// Add header comment
	header := "# Promptsfile.lock\n# Generated by prompt-sync\n# DO NOT EDIT MANUALLY\n\n"
	content := header + string(data)

	// Write to file
	if err := os.WriteFile(lockPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write lock file: %w", err)
	}

	return nil
}

// Read parses an existing lock file
func (w *Writer) Read() (*Lock, error) {
	lockPath := filepath.Join(w.workspaceDir, "Promptsfile.lock")

	data, err := os.ReadFile(lockPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to read lock file: %w", err)
	}

	// Remove header comments
	lines := strings.Split(string(data), "\n")
	var yamlLines []string
	for _, line := range lines {
		if !strings.HasPrefix(line, "#") {
			yamlLines = append(yamlLines, line)
		}
	}
	yamlContent := strings.Join(yamlLines, "\n")

	var lock Lock
	if err := yaml.Unmarshal([]byte(yamlContent), &lock); err != nil {
		return nil, fmt.Errorf("failed to parse lock file: %w", err)
	}

	return &lock, nil
}

// CalculateFileHash computes the SHA256 hash of a file
func (w *Writer) CalculateFileHash(path string) (string, error) {
	file, err := os.Open(path)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hash := sha256.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}

	return "sha256:" + hex.EncodeToString(hash.Sum(nil)), nil
}

// GetFileHashes returns a map of file paths to their hashes from the lock file
func (w *Writer) GetFileHashes() (map[string]string, error) {
	lock, err := w.Read()
	if err != nil {
		return nil, err
	}

	if lock == nil {
		return nil, nil
	}

	hashes := make(map[string]string)
	for _, source := range lock.Sources {
		for _, file := range source.Files {
			hashes[file.Path] = file.Hash
		}
	}

	return hashes, nil
}

// Exists checks if a lock file exists
func (w *Writer) Exists() bool {
	lockPath := filepath.Join(w.workspaceDir, "Promptsfile.lock")
	_, err := os.Stat(lockPath)
	return err == nil
}
