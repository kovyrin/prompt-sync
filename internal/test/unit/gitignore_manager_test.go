package unit_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/kovyrin/prompt-sync/internal/gitignore"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGitignoreManager(t *testing.T) {
	t.Run("creates new gitignore with managed block", func(t *testing.T) {
		workspace := t.TempDir()
		manager := gitignore.New(workspace)

		patterns := []string{
			".cursor/rules/_active/",
			".claude/commands/prefix-*",
		}

		err := manager.Update(patterns)
		require.NoError(t, err)

		// Verify file was created
		gitignorePath := filepath.Join(workspace, ".gitignore")
		assert.FileExists(t, gitignorePath)

		// Verify content
		content, err := os.ReadFile(gitignorePath)
		require.NoError(t, err)

		expected := `# BEGIN PROMPT-SYNC MANAGED
# DO NOT EDIT - Automatically generated by prompt-sync

.cursor/rules/_active/
.claude/commands/prefix-*
# END PROMPT-SYNC MANAGED
`
		assert.Equal(t, expected, string(content))
	})

	t.Run("updates existing gitignore preserving user content", func(t *testing.T) {
		workspace := t.TempDir()
		gitignorePath := filepath.Join(workspace, ".gitignore")

		// Create existing gitignore
		existingContent := `# User patterns
node_modules/
*.log

# Build artifacts
dist/
build/`
		err := os.WriteFile(gitignorePath, []byte(existingContent), 0644)
		require.NoError(t, err)

		manager := gitignore.New(workspace)
		patterns := []string{".cursor/rules/_active/"}

		err = manager.Update(patterns)
		require.NoError(t, err)

		// Verify content
		content, err := os.ReadFile(gitignorePath)
		require.NoError(t, err)

		// Should preserve user content and add managed block
		assert.Contains(t, string(content), "node_modules/")
		assert.Contains(t, string(content), "# BEGIN PROMPT-SYNC MANAGED")
		assert.Contains(t, string(content), ".cursor/rules/_active/")
		assert.Contains(t, string(content), "# END PROMPT-SYNC MANAGED")

		// Ensure proper spacing
		lines := strings.Split(string(content), "\n")
		managedBlockStart := -1
		for i, line := range lines {
			if line == "# BEGIN PROMPT-SYNC MANAGED" {
				managedBlockStart = i
				break
			}
		}
		assert.Greater(t, managedBlockStart, 0)
		// Should have empty line before managed block
		assert.Equal(t, "", lines[managedBlockStart-1])
	})

	t.Run("replaces existing managed block", func(t *testing.T) {
		workspace := t.TempDir()
		gitignorePath := filepath.Join(workspace, ".gitignore")

		// Create gitignore with existing managed block
		existingContent := `# User patterns
node_modules/

# BEGIN PROMPT-SYNC MANAGED
# DO NOT EDIT - Automatically generated by prompt-sync

.old-pattern/
# END PROMPT-SYNC MANAGED`
		err := os.WriteFile(gitignorePath, []byte(existingContent), 0644)
		require.NoError(t, err)

		manager := gitignore.New(workspace)
		patterns := []string{".new-pattern/"}

		err = manager.Update(patterns)
		require.NoError(t, err)

		// Verify content
		content, err := os.ReadFile(gitignorePath)
		require.NoError(t, err)

		// Should have new pattern, not old
		assert.Contains(t, string(content), ".new-pattern/")
		assert.NotContains(t, string(content), ".old-pattern/")

		// Should still have user patterns
		assert.Contains(t, string(content), "node_modules/")

		// Should only have one managed block
		assert.Equal(t, 1, strings.Count(string(content), "# BEGIN PROMPT-SYNC MANAGED"))
	})

	t.Run("verify detects missing managed block", func(t *testing.T) {
		workspace := t.TempDir()
		gitignorePath := filepath.Join(workspace, ".gitignore")

		// Create gitignore without managed block
		err := os.WriteFile(gitignorePath, []byte("node_modules/\n"), 0644)
		require.NoError(t, err)

		manager := gitignore.New(workspace)
		valid, err := manager.Verify([]string{".cursor/rules/_active/"})

		require.NoError(t, err)
		assert.False(t, valid)
	})

	t.Run("verify detects outdated managed block", func(t *testing.T) {
		workspace := t.TempDir()
		manager := gitignore.New(workspace)

		// Create initial managed block
		err := manager.Update([]string{".old-pattern/"})
		require.NoError(t, err)

		// Verify with different patterns
		valid, err := manager.Verify([]string{".new-pattern/"})
		require.NoError(t, err)
		assert.False(t, valid)

		// Verify with same patterns
		valid, err = manager.Verify([]string{".old-pattern/"})
		require.NoError(t, err)
		assert.True(t, valid)
	})

	t.Run("verify handles missing gitignore file", func(t *testing.T) {
		workspace := t.TempDir()
		manager := gitignore.New(workspace)

		valid, err := manager.Verify([]string{".cursor/rules/_active/"})
		require.NoError(t, err)
		assert.False(t, valid)
	})
}
