package unit

import (
	"bytes"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/kovyrin/prompt-sync/internal/cmd"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

func TestListCommand_BasicListing(t *testing.T) {
	t.Run("lists installed prompts from Promptsfile and lock", func(t *testing.T) {
		// Setup test environment
		testDir := t.TempDir()

		// Create test Promptsfile
		promptsfileContent := `
version: 1
sources:
  - github.com/example/prompts
  - github.com/another/pack
adapters:
  cursor:
    enabled: true
  claude:
    enabled: true
`
		require.NoError(t, createTestFile(testDir, "Promptsfile", promptsfileContent))

		// Create test lock file with header comments
		lockContent := `# Promptsfile.lock
# Generated by prompt-sync
# DO NOT EDIT MANUALLY

version: "1.0"
generated: 2024-01-01T00:00:00Z
sources:
  - url: github.com/example/prompts
    commit: abc123
    files:
      - path: .cursor/rules/_active/example-prompts-coding.md
        hash: sha256:hash1
  - url: github.com/another/pack
    commit: def456
    files:
      - path: .cursor/rules/_active/another-pack-testing.md
        hash: sha256:hash2
`
		require.NoError(t, createTestFile(testDir, "Promptsfile.lock", lockContent))

		// Execute list command
		output := &bytes.Buffer{}
		err := runListCommand(testDir, []string{}, output)
		require.NoError(t, err)

		// Verify output contains prompt information
		outputStr := output.String()
		t.Logf("Output captured: %q", outputStr)
		assert.Contains(t, outputStr, "github.com/example/prompts")
		assert.Contains(t, outputStr, "abc123")
		assert.Contains(t, outputStr, "github.com/another/pack")
		assert.Contains(t, outputStr, "def456")
	})

	t.Run("handles missing lock file gracefully", func(t *testing.T) {
		testDir := t.TempDir()

		// Only create Promptsfile, no lock
		promptsfileContent := `
version: 1
sources:
  - github.com/example/prompts
adapters:
  cursor:
    enabled: true
`
		require.NoError(t, createTestFile(testDir, "Promptsfile", promptsfileContent))

		output := &bytes.Buffer{}
		err := runListCommand(testDir, []string{}, output)
		require.NoError(t, err)

		outputStr := output.String()
		assert.Contains(t, outputStr, "github.com/example/prompts")
		assert.Contains(t, outputStr, "(not installed)")
	})

	t.Run("handles empty Promptsfile", func(t *testing.T) {
		testDir := t.TempDir()

		promptsfileContent := `
version: 1
sources: []
adapters:
  cursor:
    enabled: true
`
		require.NoError(t, createTestFile(testDir, "Promptsfile", promptsfileContent))

		output := &bytes.Buffer{}
		err := runListCommand(testDir, []string{}, output)
		require.NoError(t, err)

		outputStr := output.String()
		assert.Contains(t, outputStr, "No sources configured")
	})
}

func TestListCommand_FilesFlag(t *testing.T) {
	t.Run("shows rendered file paths with --files flag", func(t *testing.T) {
		testDir := t.TempDir()

		// Create test files and rendered outputs
		promptsfileContent := `
version: 1
sources:
  - github.com/example/prompts
adapters:
  cursor:
    enabled: true
  claude:
    enabled: true
`
		require.NoError(t, createTestFile(testDir, "Promptsfile", promptsfileContent))

		lockContent := `# Promptsfile.lock
# Generated by prompt-sync
# DO NOT EDIT MANUALLY

version: "1.0"
generated: 2024-01-01T00:00:00Z
sources:
  - url: github.com/example/prompts
    commit: abc123
    files:
      - path: .cursor/rules/_active/example-prompts-coding.md
        hash: sha256:hash1
      - path: .cursor/rules/_active/example-prompts-testing.md
        hash: sha256:hash2
      - path: .claude/commands/example-prompts-coding.md
        hash: sha256:hash3
      - path: .claude/commands/example-prompts-testing.md
        hash: sha256:hash4
`
		require.NoError(t, createTestFile(testDir, "Promptsfile.lock", lockContent))

		output := &bytes.Buffer{}
		err := runListCommand(testDir, []string{"--files"}, output)
		require.NoError(t, err)

		outputStr := output.String()
		// Should show rendered file paths
		assert.Contains(t, outputStr, ".cursor/rules/_active/example-prompts-coding.md")
		assert.Contains(t, outputStr, ".cursor/rules/_active/example-prompts-testing.md")
		assert.Contains(t, outputStr, ".claude/commands/example-prompts-coding.md")
		assert.Contains(t, outputStr, ".claude/commands/example-prompts-testing.md")
	})
}

// Helper types for JSON output
type listJSONOutput struct {
	Sources []sourceInfo `json:"sources"`
}

type sourceInfo struct {
	URL           string   `json:"url"`
	Commit        string   `json:"commit,omitempty"`
	Ref           string   `json:"ref,omitempty"`
	RenderedFiles []string `json:"rendered_files,omitempty"`
	Installed     bool     `json:"installed"`
}

// Helper function to run list command
func runListCommand(workDir string, args []string, output *bytes.Buffer) error {
	// Save current directory
	oldDir, err := os.Getwd()
	if err != nil {
		return err
	}
	defer os.Chdir(oldDir)

	// Change to test directory
	if err := os.Chdir(workDir); err != nil {
		return err
	}

	// Use the actual list command from cmd package
	// Create a new instance to avoid state issues
	listCmd := &cobra.Command{
		Use:   cmd.ListCmd.Use,
		Short: cmd.ListCmd.Short,
		Long:  cmd.ListCmd.Long,
		RunE:  cmd.ListCmd.RunE,
	}

	// Copy flag definitions from the original command
	cmd.ListCmd.Flags().VisitAll(func(f *pflag.Flag) {
		listCmd.Flags().AddFlag(f)
	})

	// Parse the flags
	if err := listCmd.ParseFlags(args); err != nil {
		return err
	}

	// Set output
	listCmd.SetOut(output)
	listCmd.SetErr(output)

	// Execute command
	return listCmd.RunE(listCmd, listCmd.Flags().Args())
}

// Helper function to create test files
func createTestFile(dir, name, content string) error {
	path := filepath.Join(dir, name)
	// Create parent directories if needed
	if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
		return err
	}
	return os.WriteFile(path, []byte(content), 0644)
}
